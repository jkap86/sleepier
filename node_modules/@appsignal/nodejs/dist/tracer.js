"use strict";
var _scopeManager;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTracer = void 0;
const tslib_1 = require("tslib");
const scope_1 = require("./scope");
const span_1 = require("./span");
const noops_1 = require("./noops");
/**
 * The tracer object.
 *
 * @class
 */
class BaseTracer {
    constructor() {
        _scopeManager.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _scopeManager, new scope_1.ScopeManager().enable());
    }
    /**
     * Creates a new `Span` instance.
     */
    createSpan(options, spanOrContext) {
        const activeRootSpan = this.rootSpan();
        if (spanOrContext && !(spanOrContext instanceof noops_1.NoopSpan)) {
            return new span_1.ChildSpan(spanOrContext, options);
        }
        else if (activeRootSpan instanceof noops_1.NoopSpan) {
            return this.createRootSpan(options);
        }
        else {
            return new span_1.ChildSpan(activeRootSpan, options);
        }
    }
    createRootSpan(options) {
        const rootSpan = new span_1.RootSpan(options);
        tslib_1.__classPrivateFieldGet(this, _scopeManager).setRoot(rootSpan);
        return rootSpan;
    }
    /**
     * Returns the current Span.
     *
     * If there is no current Span available, `undefined` is returned.
     */
    currentSpan() {
        return tslib_1.__classPrivateFieldGet(this, _scopeManager).active() || new noops_1.NoopSpan();
    }
    /*
     * Returns the root Span.
     *
     * If there is no root Span available, a NoopSpan is returned.
     */
    rootSpan() {
        return tslib_1.__classPrivateFieldGet(this, _scopeManager).root() || new noops_1.NoopSpan();
    }
    /*
     * Adds the given error to the root Span.
     *
     * If there is no root Span available, a NoopSpan will be used instead,
     * and nothing will be tracked.
     */
    setError(error) {
        const activeRootSpan = this.rootSpan();
        activeRootSpan.setError(error);
        return activeRootSpan;
    }
    /**
     * Sends an error in a newly created `RootSpan` that will be closed after
     * the given error is added to it.
     *
     * The created `RootSpan` is passed as the single argument to the given function.
     * This allows you to add arbitrary metadata to it.
     */
    sendError(error, fn) {
        const rootSpan = new span_1.RootSpan();
        rootSpan.setError(error);
        if (fn && typeof fn === "function")
            fn(rootSpan);
        rootSpan.close();
    }
    /**
     * Executes a given function within the context of a given `Span`. When the
     * function has finished executing, any value returned by the given function
     * is returned, but the `Span` remains active unless it is explicitly closed.
     *
     * The `Span` is passed as the single argument to the given function. This
     * allows you to create children of the `Span` for instrumenting nested
     * operations.
     */
    withSpan(span, fn) {
        return tslib_1.__classPrivateFieldGet(this, _scopeManager).withContext(span, fn);
    }
    /**
     * Wraps a given function in the current `Span`s scope.
     */
    wrap(fn) {
        return tslib_1.__classPrivateFieldGet(this, _scopeManager).bindContext(fn);
    }
    /**
     * Wraps an `EventEmitter` in the current `Span`s scope.
     */
    wrapEmitter(emitter) {
        return tslib_1.__classPrivateFieldGet(this, _scopeManager).emitWithContext(emitter);
    }
}
exports.BaseTracer = BaseTracer;
_scopeManager = new WeakMap();
