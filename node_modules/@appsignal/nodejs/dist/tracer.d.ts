/// <reference types="node" />
import { Func } from "@appsignal/types";
import { Tracer, Span, SpanOptions, SpanContext } from "./interfaces";
import { EventEmitter } from "events";
/**
 * The tracer object.
 *
 * @class
 */
export declare class BaseTracer implements Tracer {
    #private;
    constructor();
    /**
     * Creates a new `Span` instance. If a `Span` is passed as the optional second
     * argument, then the returned `Span` will be a `ChildSpan`.
     */
    createSpan(options?: Partial<SpanOptions>, span?: Span): Span;
    /**
     * Creates a new `Span` instance. If a `SpanContext` is passed as the optional second
     * argument, then the returned `Span` will be a `ChildSpan`.
     */
    createSpan(options?: Partial<SpanOptions>, context?: SpanContext): Span;
    createRootSpan(options?: Partial<SpanOptions>): Span;
    /**
     * Returns the current Span.
     *
     * If there is no current Span available, `undefined` is returned.
     */
    currentSpan(): Span;
    rootSpan(): Span;
    setError(error: Error): Span | undefined;
    /**
     * Sends an error in a newly created `RootSpan` that will be closed after
     * the given error is added to it.
     *
     * The created `RootSpan` is passed as the single argument to the given function.
     * This allows you to add arbitrary metadata to it.
     */
    sendError<T>(error: Error, fn?: (s: Span) => T): void;
    /**
     * Executes a given function within the context of a given `Span`. When the
     * function has finished executing, any value returned by the given function
     * is returned, but the `Span` remains active unless it is explicitly closed.
     *
     * The `Span` is passed as the single argument to the given function. This
     * allows you to create children of the `Span` for instrumenting nested
     * operations.
     */
    withSpan<T>(span: Span, fn: (s: Span) => T): T;
    /**
     * Wraps a given function in the current `Span`s scope.
     */
    wrap<T>(fn: Func<T>): Func<T>;
    /**
     * Wraps an `EventEmitter` in the current `Span`s scope.
     */
    wrapEmitter(emitter: EventEmitter): void;
}
