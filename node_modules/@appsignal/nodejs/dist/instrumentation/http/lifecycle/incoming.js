"use strict";
/**
 * Uses portions of `opentelemetry-js`
 * https://github.com/open-telemetry/opentelemetry-js/blob/master/packages/opentelemetry-plugin-http/src/http.ts
 * Copyright 2019, OpenTelemetry Authors
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPatchIncomingRequestFunction = void 0;
const url_1 = require("url");
// explicitly ignore some urls that we can't guarantee groupings on, or
// routes that cause known issues.
// submit a pull request if you have any potential candidates for this array!
const DEFAULT_IGNORED_URLS = [
    // common static asset paths (with any query string)
    /\.(css|js|jpg|jpeg|gif|png|svg|webp|json|ico|webmanifest|jsx|less|swf|eot|ttf|otf|woff|woff2)((\?|&)([^=]+)=([^&]+))*$/i,
    // next.js related routes
    /(\/_next)/i,
    // gatsby hot reloading
    /(\/__webpack_hmr)/i,
    // next.js integration web vitals endpoint
    /(\/__appsignal-web-vitals)$/i,
    // socket.io default path
    /^(\/socket.io)/i
];
function incomingRequest(original, tracer) {
    return function (event, ...args) {
        if (event !== "request") {
            return original.apply(this, [event, ...args]);
        }
        const [req, res] = args;
        const { method = "GET", url = "/", headers } = req;
        const { pathname, query } = url_1.parse(url);
        const allowedHeaders = filterHeaders(headers);
        // don't start a span for ignored urls
        if (url && DEFAULT_IGNORED_URLS.some(el => el.test(url))) {
            return original.apply(this, [event, ...args]);
        }
        const rootSpan = tracer
            .createRootSpan()
            /**
             * For our processor to work, root `Span`s must have a groupable, non-dynamic
             * name to be easily grouped into performance samples.
             *
             * For example, `GET /` is not dynamic, so we can safely set that as the `Span`
             * name here if that is indeed the current pathname. However, setting a name using a
             * dynamic path like `GET /user/13123` would cause a new sample to appear for every
             * user id, which leads to undesirable behavior.
             *
             * Therefore, it is the responsibility of an integration to update the span name with a
             * groupable value. For example, the Express integration will update the span name to the
             * resolved `req.route.path` value (e.g. `GET /user/:userId`).
             */
            .setName(`${method} ${pathname === "/" ? pathname : "[unknown route]"}`)
            .setCategory("process_request.http")
            .set("method", method)
            .setSampleData("environment", allowedHeaders)
            .setSampleData("params", query ? { query } : {});
        return tracer.withSpan(rootSpan, span => {
            // calling this binds the event handlers to our current
            // async context
            tracer.wrapEmitter(req);
            tracer.wrapEmitter(res);
            const originalEnd = res.end;
            // wraps the "end" event to close the span
            res.end = function (...args) {
                res.end = originalEnd;
                const result = res.end.apply(this, [...args]);
                span.set("status_code", res.statusCode).close();
                return result;
            };
            return original.apply(this, [event, ...args]);
        });
    };
}
function filterHeaders(headers) {
    const filtered = {};
    const headersAllowList = global.__APPSIGNAL__.config.data.requestHeaders || [];
    headersAllowList.forEach(key => {
        if (headers[key] != undefined) {
            filtered[key] = headers[key];
        }
    });
    return filtered;
}
function getPatchIncomingRequestFunction(tracer) {
    return function (original) {
        return incomingRequest(original, tracer);
    };
}
exports.getPatchIncomingRequestFunction = getPatchIncomingRequestFunction;
