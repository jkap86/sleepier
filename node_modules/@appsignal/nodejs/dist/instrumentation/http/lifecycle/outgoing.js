"use strict";
/**
 * Uses portions of `opentelemetry-js`
 * https://github.com/open-telemetry/opentelemetry-js/blob/master/packages/opentelemetry-plugin-http/src/http.ts
 * Copyright 2019, OpenTelemetry Authors
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPatchOutgoingRequestFunction = exports.getPatchOutgoingGetFunction = void 0;
const tslib_1 = require("tslib");
const url_1 = tslib_1.__importDefault(require("url"));
// explicitly ignore some urls or routes that cause known issues.
// submit a pull request if you have any potential candidates for this array!
const DEFAULT_IGNORED_URLS = [
    // next.js telemetry
    /telemetry\.nextjs\.org/i
];
function optionsToOriginString(options) {
    var _a, _b, _c, _d, _e, _f;
    let protocol = "http:";
    let hostname = "localhost";
    if (options instanceof url_1.default.URL) {
        return (_a = options.origin) !== null && _a !== void 0 ? _a : `${protocol}//${hostname}`;
    }
    else if (typeof options === "string") {
        const parsed = url_1.default.parse(options);
        protocol = (_b = parsed.protocol) !== null && _b !== void 0 ? _b : protocol;
        hostname = (_c = parsed.hostname) !== null && _c !== void 0 ? _c : hostname;
    }
    else {
        // is a `RequestOptions` object
        protocol = (_d = options.protocol) !== null && _d !== void 0 ? _d : protocol;
        hostname = (_f = (_e = options.hostname) !== null && _e !== void 0 ? _e : options.host) !== null && _f !== void 0 ? _f : hostname;
    }
    return `${protocol}//${hostname}`;
}
function optionsToMethodName(options) {
    if (
    // is a RequestOptions
    typeof options !== "string" &&
        !(options instanceof url_1.default.URL) &&
        options.method) {
        return options.method ? options.method.toUpperCase() : "GET";
    }
    else {
        return "GET";
    }
}
function outgoingRequestFunction(original, tracer) {
    return function outgoingRequest(urlOrOptions, ...args) {
        let origin;
        let method;
        if (args[0] && typeof args[0] !== "function") {
            // an options object may have been passed
            const otherOptions = args[0];
            method = optionsToMethodName(otherOptions);
            origin = optionsToOriginString(otherOptions);
        }
        else {
            method = optionsToMethodName(urlOrOptions);
            origin = optionsToOriginString(urlOrOptions);
        }
        // don't start a span for ignored urls
        if (origin && DEFAULT_IGNORED_URLS.some(el => el.test(origin))) {
            return original.apply(this, [urlOrOptions, ...args]);
        }
        const span = tracer
            .createSpan()
            .setName(`${method} ${origin}`)
            .setCategory("request.http")
            .set("method", method);
        return tracer.withSpan(span, () => {
            let req;
            try {
                req = original.apply(this, [urlOrOptions, ...args]);
            }
            catch (err) {
                tracer.setError(err);
                span.close();
                throw err;
            }
            tracer.wrapEmitter(req);
            req.on("response", res => {
                tracer.wrapEmitter(res);
                res.on("end", () => {
                    span.close();
                });
            });
            req.on("close", () => {
                span.close();
            });
            req.on("error", (error) => {
                tracer.setError(error);
                span.close();
            });
            return req;
        });
    };
}
function getPatchOutgoingGetFunction(clientRequest) {
    return () => {
        // it's important to note that the `clientRequest` function called below
        // is the patched version of `http.request` that we patched earlier
        return function outgoingGetRequest(options, ...args) {
            const req = clientRequest.apply(this, [options, ...args]);
            req.end();
            return req;
        };
    };
}
exports.getPatchOutgoingGetFunction = getPatchOutgoingGetFunction;
function getPatchOutgoingRequestFunction(tracer) {
    return (original) => {
        return outgoingRequestFunction(original, tracer);
    };
}
exports.getPatchOutgoingRequestFunction = getPatchOutgoingRequestFunction;
