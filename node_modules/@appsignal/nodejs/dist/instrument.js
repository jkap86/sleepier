"use strict";
var _tracer, _meter;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Instrumentation = void 0;
const tslib_1 = require("tslib");
const client_1 = require("./client");
const require_in_the_middle_1 = tslib_1.__importDefault(require("require-in-the-middle"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const utils_1 = require("./utils");
/**
 * The Instrumentation class.
 * @class
 */
class Instrumentation {
    constructor(tracer, meter) {
        _tracer.set(this, void 0);
        _meter.set(this, void 0);
        this.active = [];
        tslib_1.__classPrivateFieldSet(this, _tracer, tracer);
        tslib_1.__classPrivateFieldSet(this, _meter, meter);
    }
    /**
     * Loads custom instrumentation for a given module. The instrumentation is
     * loaded when a modules is required using the global `require` function.
     */
    load(name, fn) {
        const hook = require_in_the_middle_1.default([name], (mod, _, basedir) => {
            // we use the current node version as the given version
            // if the module is internal (i.e. no `package.json`)
            const version = basedir
                ? utils_1.getPackageVerson(basedir)
                : process.versions.node;
            // init the plugin
            const plugin = fn(mod, tslib_1.__classPrivateFieldGet(this, _tracer), tslib_1.__classPrivateFieldGet(this, _meter));
            // install if version range matches
            if (semver_1.default.satisfies(version, plugin.version)) {
                return plugin.install();
            }
            else {
                client_1.BaseClient.logger.warn(`Unable to instrument module ${name}, module version needs to satisfy version range ${plugin.version}`);
                return mod;
            }
        });
        this.active.push({ name, hook });
        return;
    }
    /**
     * Removes all custom instrumentation for a given module name. Any
     * subsequent calls to `require` for this instrumentation after calling
     * this method will not include instrumentation.
     */
    unload(name) {
        this.active = this.active.filter(active => {
            if (active.name !== name) {
                return true;
            }
            else {
                const { hook } = active;
                hook.unhook();
                return false;
            }
        });
        return;
    }
    /**
     * Removes all custom instrumentation. Any subsequent calls to `require`
     * after calling this method will not include instrumentation.
     */
    unloadAll() {
        this.active.forEach(active => {
            const { hook } = active;
            hook.unhook();
        });
        this.active = [];
        return;
    }
}
exports.Instrumentation = Instrumentation;
_tracer = new WeakMap(), _meter = new WeakMap();
