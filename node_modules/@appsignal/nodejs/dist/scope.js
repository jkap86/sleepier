"use strict";
/**
 * Uses portions of `opentelemetry-js`
 * https://github.com/open-telemetry/opentelemetry-js/blob/master/packages/opentelemetry-scope-async-hooks/src/AsyncHooksScopeManager.ts
 * Copyright 2019, OpenTelemetry Authors
 *
 * Uses portions of `cloud-trace-nodejs`
 * https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/cls/async-hooks.ts
 * Copyright 2018, Google LLC
 */
var _roots, _scopes, _asyncHook, _map;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScopeManager = void 0;
const tslib_1 = require("tslib");
const asyncHooks = tslib_1.__importStar(require("async_hooks"));
const shimmer_1 = tslib_1.__importDefault(require("shimmer"));
const span_1 = require("./noops/span");
// A list of well-known EventEmitter methods that add event listeners.
const EVENT_EMITTER_ADD_METHODS = [
    "addListener",
    "on",
    "once",
    "prependListener",
    "prependOnceListener"
];
// A list of well-known EventEmitter methods that remove event listeners.
const EVENT_EMITTER_REMOVE_METHODS = [
    "off",
    "removeListener"
];
const WRAPPED = Symbol("@appsignal/nodejs:WRAPPED");
/**
 * Propagates specific scope between function calls and async operations.
 *
 * @class
 */
class ScopeManager {
    constructor() {
        _roots.set(this, void 0);
        _scopes.set(this, void 0);
        _asyncHook.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _roots, new Map());
        tslib_1.__classPrivateFieldSet(this, _scopes, new Map());
        const init = (id, type, triggerId) => {
            // Move the current span and root over to the scopes and roots map for
            // the child executionAsyncId.
            const transferSpanScope = (list, newId, oldId) => {
                const span = list.get(oldId);
                if (span && span.open) {
                    list.set(newId, list.get(oldId));
                }
            };
            /**
             * We use the `executionAsyncId` here, as using the `triggerId` causes context
             * confusion in applications using async/await.
             */
            if (type === "PROMISE") {
                const currentId = asyncHooks.executionAsyncId();
                transferSpanScope(tslib_1.__classPrivateFieldGet(this, _scopes), id, currentId);
                transferSpanScope(tslib_1.__classPrivateFieldGet(this, _roots), id, currentId);
            }
            else {
                /**
                 * `triggerId` usually equal the ID of the AsyncResource in whose scope we are
                 * currently running (the "current" `AsyncResource`), or that of one
                 * of its ancestors, so the behavior is not expected to be different
                 * from using the ID of the current AsyncResource instead.
                 *
                 * However, as the `triggerId` can be defined in userland, we choose to respect th
                 */
                transferSpanScope(tslib_1.__classPrivateFieldGet(this, _scopes), id, triggerId);
                transferSpanScope(tslib_1.__classPrivateFieldGet(this, _roots), id, triggerId);
            }
        };
        /**
         * When the `AsyncResource` is destroyed, we destroy the reference to the `Span`. The same
         * callback is called when a promise is resolved.
         */
        const destroy = (id) => {
            this.removeSpanForUid(id);
        };
        tslib_1.__classPrivateFieldSet(this, _asyncHook, asyncHooks.createHook({
            init: init,
            destroy: destroy,
            promiseResolve: destroy
        }));
    }
    /**
     * Enables the async hook.
     */
    enable() {
        tslib_1.__classPrivateFieldGet(this, _asyncHook).enable();
        return this;
    }
    /**
     * Disables the async hook and clears the current `Span`s. Will generally
     * only need to be called by the test suite.
     */
    disable() {
        tslib_1.__classPrivateFieldGet(this, _asyncHook).disable();
        tslib_1.__classPrivateFieldSet(this, _scopes, new Map());
        return this;
    }
    setActive(span) {
        if (span.open) {
            const uid = asyncHooks.executionAsyncId();
            tslib_1.__classPrivateFieldGet(this, _scopes).set(uid, span);
        }
    }
    /**
     * Unset any active span for the current executionAsyncId.
     */
    unsetActive() {
        const uid = asyncHooks.executionAsyncId();
        tslib_1.__classPrivateFieldGet(this, _scopes).delete(uid);
    }
    /**
     * Returns the current active `Span`.
     */
    active() {
        const uid = asyncHooks.executionAsyncId();
        const span = tslib_1.__classPrivateFieldGet(this, _scopes).get(uid);
        // Perform check if the span is not closed. A span that has been closed
        // can't be considered an active span anymore.
        if (span && span.open) {
            // Span exists and is still open. These conditions make it a valid, still
            // active, span.
            return span;
        }
        else {
            // Clear any reference to this span in the scopes manager to avoid
            // confusion next time the active span is fetched.
            this.removeSpanForUid(uid);
        }
    }
    /**
     * Sets the root `Span`
     */
    setRoot(rootSpan) {
        if (rootSpan.open) {
            const uid = asyncHooks.executionAsyncId();
            tslib_1.__classPrivateFieldGet(this, _roots).set(uid, rootSpan);
            tslib_1.__classPrivateFieldGet(this, _scopes).set(uid, rootSpan);
        }
    }
    /*
     * Returns the current root `Span`.
     */
    root() {
        const uid = asyncHooks.executionAsyncId();
        const span = tslib_1.__classPrivateFieldGet(this, _roots).get(uid);
        // Perform check if the span is not closed. A span that has been closed
        // can't be considered a root span anymore.
        if (span && span.open) {
            // Span exists and is still open. These conditions make it a valid, still
            // root, span.
            return span;
        }
        else {
            // Clear any reference to this span in the scopes manager to avoid
            // confusion next time the root span is fetched.
            this.removeSpanForUid(uid);
        }
    }
    /*
     * Remove the Span for the given executionAsyncId from all scopes.
     */
    removeSpanForUid(uid) {
        tslib_1.__classPrivateFieldGet(this, _scopes).delete(uid);
        tslib_1.__classPrivateFieldGet(this, _roots).delete(uid);
    }
    /**
     * Executes a given function within the context of a given `Span`.
     */
    withContext(span, fn) {
        var _a;
        const oldScope = this.active();
        if (span.open) {
            this.setActive(span);
        }
        else {
            span = oldScope || new span_1.NoopSpan();
        }
        try {
            return fn(span);
        }
        catch (err) {
            (_a = this.root()) === null || _a === void 0 ? void 0 : _a.setError(err);
            throw err;
        }
        finally {
            // Unset the current active span so it doesn't leak outside this context
            // in case there was no previous active span or it's no longer open.
            this.unsetActive();
            if (oldScope) {
                // Revert the current active span
                this.setActive(oldScope);
            }
        }
    }
    bindContext(fn) {
        // return if we have already wrapped the function
        if (fn[WRAPPED]) {
            return fn;
        }
        // capture the context of the current `AsyncResource`
        const boundContext = this.active();
        // return if there is no current context to bind
        if (!boundContext) {
            return fn;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        // wrap `fn` so that any AsyncResource objects that are created in `fn` will
        // share context with that of the `AsyncResource` with the given ID.
        const contextWrapper = function (...args) {
            return self.withContext(boundContext, () => fn.apply(this, args));
        };
        // prevent re-wrapping
        contextWrapper[WRAPPED] = true;
        // explicitly inherit the original function's length and name
        Object.defineProperty(contextWrapper, "length", {
            configurable: true,
            value: fn.length
        });
        Object.defineProperty(contextWrapper, "name", {
            configurable: true,
            value: fn.name
        });
        return contextWrapper;
    }
    emitWithContext(ee) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const thisScopeManager = this;
        // For each event and callback that is registered with the event emitter,
        // `boundCallbacks` keeps a reference to the newly-created context-bound
        // callback that wraps around the original callback.
        // A listener with the same event and callback could be added from
        // different asynchronous contexts, meaning its context-bound wrapper
        // should bind it to a different scope, so it keeps a list of
        // context-bound callbacks for a single event and callback pair.
        const boundCallbacks = new BoundCallbacks();
        EVENT_EMITTER_ADD_METHODS.forEach(method => {
            if (ee[method]) {
                shimmer_1.default.wrap(ee, method, (oldFn) => {
                    return function (event, cb) {
                        const boundCallback = thisScopeManager.bindContext(cb);
                        boundCallbacks.push(event, cb, boundCallback);
                        return oldFn.call(this, event, boundCallback);
                    };
                });
            }
        });
        EVENT_EMITTER_REMOVE_METHODS.forEach(method => {
            if (ee[method]) {
                shimmer_1.default.wrap(ee, method, (oldFn) => {
                    return function (event, cb) {
                        var _a;
                        // If there is no bound callback for this event and callback, it
                        // might be a listener that was added before the event emitter was
                        // wrapped, so we should attempt to remove the given callback.
                        const maybeBoundCallback = (_a = boundCallbacks.pop(event, cb)) !== null && _a !== void 0 ? _a : cb;
                        return oldFn.call(this, event, maybeBoundCallback);
                    };
                });
            }
        });
    }
}
exports.ScopeManager = ScopeManager;
_roots = new WeakMap(), _scopes = new WeakMap(), _asyncHook = new WeakMap();
class BoundCallbacks {
    constructor() {
        _map.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _map, new Map());
    }
    push(event, cb, boundCallback) {
        let eventMap = tslib_1.__classPrivateFieldGet(this, _map).get(event);
        if (!eventMap) {
            eventMap = new WeakMap();
            tslib_1.__classPrivateFieldGet(this, _map).set(event, eventMap);
        }
        let callbacks = eventMap.get(cb);
        if (!callbacks) {
            callbacks = [];
            eventMap.set(cb, callbacks);
        }
        callbacks.push(boundCallback);
    }
    pop(event, cb) {
        const eventMap = tslib_1.__classPrivateFieldGet(this, _map).get(event);
        if (!eventMap)
            return;
        const callbacks = eventMap.get(cb);
        if (!callbacks)
            return;
        return callbacks.pop();
    }
}
_map = new WeakMap();
