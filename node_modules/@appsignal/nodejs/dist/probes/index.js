"use strict";
var _probes, _running, _timers;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Probes = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
/**
 * The Minutely probes object.
 */
class Probes {
    constructor({ run = true } = {}) {
        _probes.set(this, void 0);
        _running.set(this, true);
        tslib_1.__classPrivateFieldSet(this, _probes, new BaseProbeRunner());
        if (!run)
            this.stop();
    }
    stop() {
        tslib_1.__classPrivateFieldGet(this, _probes).clear();
        tslib_1.__classPrivateFieldSet(this, _probes, new NoopProbeRunner());
        tslib_1.__classPrivateFieldSet(this, _running, false);
        return this;
    }
    get isRunning() {
        return tslib_1.__classPrivateFieldGet(this, _running);
    }
    get count() {
        return tslib_1.__classPrivateFieldGet(this, _probes).count;
    }
    register(name, fn) {
        tslib_1.__classPrivateFieldGet(this, _probes).register(name, fn);
        return this;
    }
    unregister(name) {
        tslib_1.__classPrivateFieldGet(this, _probes).unregister(name);
        return this;
    }
    clear() {
        tslib_1.__classPrivateFieldGet(this, _probes).clear();
        return this;
    }
}
exports.Probes = Probes;
_probes = new WeakMap(), _running = new WeakMap();
class BaseProbeRunner extends events_1.EventEmitter {
    constructor() {
        super();
        _timers.set(this, new Map());
    }
    /**
     * Number of probes that are registered.
     */
    get count() {
        return tslib_1.__classPrivateFieldGet(this, _timers).size;
    }
    /**
     * Registers a new minutely probe. Using a probe `name` that has already been set
     * will overwrite the current probe.
     */
    register(name, fn) {
        tslib_1.__classPrivateFieldGet(this, _timers).set(name, setInterval(() => this.emit(name), 60 * 1000));
        this.removeAllListeners(name);
        this.on(name, fn);
    }
    unregister(name) {
        const timer = tslib_1.__classPrivateFieldGet(this, _timers).get(name);
        if (typeof timer !== "undefined") {
            clearInterval(timer);
            tslib_1.__classPrivateFieldGet(this, _timers).delete(name);
            this.removeAllListeners(name);
        }
    }
    /**
     * Unregisters all probes and clears the timers.
     */
    clear() {
        tslib_1.__classPrivateFieldGet(this, _timers).forEach(t => clearInterval(t));
        tslib_1.__classPrivateFieldSet(this, _timers, new Map());
        this.removeAllListeners();
    }
}
_timers = new WeakMap();
class NoopProbeRunner {
    constructor() {
        this.count = 0;
    }
    register(_name, _fn) {
        return;
    }
    unregister(_name) {
        return;
    }
    clear() {
        return;
    }
}
